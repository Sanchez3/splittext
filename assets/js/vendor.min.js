/******/ !function(e) {
    /******/
    /******/
    // The require function
    /******/
    function n(t) {
        /******/
        /******/
        // Check if module is in cache
        /******/
        if (o[t]) /******/
        return o[t].exports;
        /******/
        // Create a new module (and put it into the cache)
        /******/
        var r = o[t] = {
            /******/
            i: t,
            /******/
            l: false,
            /******/
            exports: {}
        };
        /******/
        /******/
        // Return the exports of the module
        /******/
        /******/
        /******/
        // Execute the module function
        /******/
        /******/
        /******/
        // Flag the module as loaded
        /******/
        return e[t].call(r.exports, r, r.exports, n), r.l = true, r.exports;
    }
    // webpackBootstrap
    /******/
    // install a JSONP callback for chunk loading
    /******/
    var t = window.webpackJsonp;
    /******/
    window.webpackJsonp = function(o, a, i) {
        /******/
        for (/******/
        // add "moreModules" to the modules object,
        /******/
        // then flag all "chunkIds" as loaded and fire callback
        /******/
        var u, s, d, _ = 0, l = []; _ < o.length; _++) /******/
        s = o[_], /******/
        r[s] && /******/
        l.push(r[s][0]), /******/
        r[s] = 0;
        /******/
        for (u in a) /******/
        Object.prototype.hasOwnProperty.call(a, u) && (/******/
        e[u] = a[u]);
        /******/
        t && t(o, a, i);
        /******/
        while (l.length) /******/
        l.shift()();
        /******/
        if (i) /******/
        for (_ = 0; _ < i.length; _++) /******/
        d = n(n.s = i[_]);
        /******/
        return d;
    };
    /******/
    /******/
    // The module cache
    /******/
    var o = {}, r = {
        /******/
        1: 0
    };
    /******/
    /******/
    // Load entry module and return exports
    /******/
    /******/
    /******/
    // This file contains only the entry chunk.
    /******/
    // The chunk loading function for additional chunks
    /******/
    n.e = function(e) {
        /******/
        function t() {
            /******/
            // avoid mem leaks in IE.
            /******/
            u.onerror = u.onload = null, /******/
            clearTimeout(s);
            /******/
            var n = r[e];
            /******/
            0 !== n && (/******/
            n && /******/
            n[1](new Error("Loading chunk " + e + " failed.")), /******/
            r[e] = void 0);
        }
        /******/
        var o = r[e];
        /******/
        if (0 === o) /******/
        return new Promise(function(e) {
            e();
        });
        /******/
        /******/
        // a Promise means "currently loading".
        /******/
        if (o) /******/
        return o[2];
        /******/
        /******/
        // setup Promise in chunk cache
        /******/
        var a = new Promise(function(n, t) {
            /******/
            o = r[e] = [ n, t ];
        });
        /******/
        o[2] = a;
        /******/
        /******/
        // start chunk loading
        /******/
        var i = document.getElementsByTagName("head")[0], u = document.createElement("script");
        /******/
        u.type = "text/javascript", /******/
        u.charset = "utf-8", /******/
        u.async = true, /******/
        u.timeout = 12e4, /******/
        /******/
        n.nc && /******/
        u.setAttribute("nonce", n.nc), /******/
        u.src = n.p + "assets/js/" + e + ".min.js";
        /******/
        var s = setTimeout(t, 12e4);
        /******/
        /******/
        /******/
        /******/
        return u.onerror = u.onload = t, i.appendChild(u), a;
    }, /******/
    /******/
    // expose the modules object (__webpack_modules__)
    /******/
    n.m = e, /******/
    /******/
    // expose the module cache
    /******/
    n.c = o, /******/
    /******/
    // define getter function for harmony exports
    /******/
    n.d = function(e, t, o) {
        /******/
        n.o(e, t) || /******/
        Object.defineProperty(e, t, {
            /******/
            configurable: false,
            /******/
            enumerable: true,
            /******/
            get: o
        });
    }, /******/
    /******/
    // getDefaultExport function for compatibility with non-harmony modules
    /******/
    n.n = function(e) {
        /******/
        var t = e && e.__esModule ? /******/
        function() {
            return e.default;
        } : /******/
        function() {
            return e;
        };
        /******/
        /******/
        return n.d(t, "a", t), t;
    }, /******/
    /******/
    // Object.prototype.hasOwnProperty.call
    /******/
    n.o = function(e, n) {
        return Object.prototype.hasOwnProperty.call(e, n);
    }, /******/
    /******/
    // __webpack_public_path__
    /******/
    n.p = "./", /******/
    /******/
    // on error function for async loading
    /******/
    n.oe = function(e) {
        throw console.error(e), e;
    }, n(n.s = 0);
}([ /* 0 */
/***/
function(e, n, t) {
    e.exports = t(1);
}, /* 1 */
/***/
function(e, n, t) {
    /* WEBPACK VAR INJECTION */
    (function(t) {
        var o, r;
        /*!
 *  howler.js v2.0.4
 *  howlerjs.com
 *
 *  (c) 2013-2017, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
        !function() {
            "use strict";
            /** Global Methods **/
            /***************************************************************************/
            /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
            var a = function() {
                this.init();
            };
            a.prototype = {
                /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
                init: function() {
                    var e = this || i;
                    // Create a global ID counter.
                    // Internal properties.
                    // Public properties.
                    // Set to false to disable the auto iOS enabler.
                    // Setup the various state values for global tracking.
                    return e._counter = 1e3, e._codecs = {}, e._howls = [], e._muted = false, e._volume = 1, 
                    e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, 
                    e.masterGain = null, e.noAudio = false, e.usingWebAudio = true, e.autoSuspend = true, 
                    e.ctx = null, e.mobileAutoEnable = true, e._setup(), e;
                },
                /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
                volume: function(e) {
                    var n = this || i;
                    if (e = parseFloat(e), // If we don't have an AudioContext created yet, run the setup.
                    n.ctx || p(), void 0 !== e && e >= 0 && e <= 1) {
                        // Don't update any of the nodes if we are muted.
                        if (n._volume = e, n._muted) return n;
                        // When using Web Audio, we just need to adjust the master gain.
                        n.usingWebAudio && (n.masterGain.gain.value = e);
                        // Loop through and change volume for all HTML5 audio nodes.
                        for (var t = 0; t < n._howls.length; t++) if (!n._howls[t]._webAudio) // Loop through all sounds and change the volumes.
                        for (var o = n._howls[t]._getSoundIds(), r = 0; r < o.length; r++) {
                            var a = n._howls[t]._soundById(o[r]);
                            a && a._node && (a._node.volume = a._volume * e);
                        }
                        return n;
                    }
                    return n._volume;
                },
                /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
                mute: function(e) {
                    var n = this || i;
                    // If we don't have an AudioContext created yet, run the setup.
                    n.ctx || p(), n._muted = e, // With Web Audio, we just need to mute the master gain.
                    n.usingWebAudio && (n.masterGain.gain.value = e ? 0 : n._volume);
                    // Loop through and mute all HTML5 Audio nodes.
                    for (var t = 0; t < n._howls.length; t++) if (!n._howls[t]._webAudio) // Loop through all sounds and mark the audio node as muted.
                    for (var o = n._howls[t]._getSoundIds(), r = 0; r < o.length; r++) {
                        var a = n._howls[t]._soundById(o[r]);
                        a && a._node && (a._node.muted = !!e || a._muted);
                    }
                    return n;
                },
                /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
                unload: function() {
                    for (var e = this || i, n = e._howls.length - 1; n >= 0; n--) e._howls[n].unload();
                    // Create a new AudioContext to make sure it is fully reset.
                    return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, 
                    p()), e;
                },
                /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
                codecs: function(e) {
                    return (this || i)._codecs[e.replace(/^x-/, "")];
                },
                /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
                _setup: function() {
                    var e = this || i;
                    // Check if audio is available.
                    if (// Keeps track of the suspend/resume state of the AudioContext.
                    e.state = e.ctx ? e.ctx.state || "running" : "running", // Automatically begin the 30-second suspend process
                    e._autoSuspend(), !e.usingWebAudio) // No audio is available on this system if noAudio is set to true.
                    if ("undefined" != typeof Audio) try {
                        var n = new Audio();
                        // Check if the canplaythrough event is available.
                        void 0 === n.oncanplaythrough && (e._canPlayEvent = "canplay");
                    } catch (n) {
                        e.noAudio = true;
                    } else e.noAudio = true;
                    // Test to make sure audio isn't disabled in Internet Explorer.
                    try {
                        var n = new Audio();
                        n.muted && (e.noAudio = true);
                    } catch (e) {}
                    // Check for supported codecs.
                    return e.noAudio || e._setupCodecs(), e;
                },
                /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
                _setupCodecs: function() {
                    var e = this || i, n = null;
                    // Must wrap in a try/catch because IE11 in server mode throws an error.
                    try {
                        n = "undefined" != typeof Audio ? new Audio() : null;
                    } catch (n) {
                        return e;
                    }
                    if (!n || "function" != typeof n.canPlayType) return e;
                    var t = n.canPlayType("audio/mpeg;").replace(/^no$/, ""), o = e._navigator && e._navigator.userAgent.match(/OPR\/([0-6].)/g), r = o && parseInt(o[0].split("/")[1], 10) < 33;
                    return e._codecs = {
                        mp3: !!(!r && (t || n.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                        mpeg: !!t,
                        opus: !!n.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                        ogg: !!n.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        oga: !!n.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        wav: !!n.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
                        aac: !!n.canPlayType("audio/aac;").replace(/^no$/, ""),
                        caf: !!n.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                        m4a: !!(n.canPlayType("audio/x-m4a;") || n.canPlayType("audio/m4a;") || n.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        mp4: !!(n.canPlayType("audio/x-mp4;") || n.canPlayType("audio/mp4;") || n.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        weba: !!n.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                        webm: !!n.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                        dolby: !!n.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                        flac: !!(n.canPlayType("audio/x-flac;") || n.canPlayType("audio/flac;")).replace(/^no$/, "")
                    }, e;
                },
                /**
     * Mobile browsers will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
                _enableMobileAudio: function() {
                    var e = this || i, n = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(e._navigator && e._navigator.userAgent), t = !!("ontouchend" in window || e._navigator && e._navigator.maxTouchPoints > 0 || e._navigator && e._navigator.msMaxTouchPoints > 0);
                    if (!e._mobileEnabled && e.ctx && (n || t)) {
                        e._mobileEnabled = false, // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
                        // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
                        // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
                        e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = true, e.unload()), 
                        // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
                        // http://stackoverflow.com/questions/24119684
                        e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);
                        // Call this method on touch start to create and play a buffer,
                        // then check if the audio actually played to determine if
                        // audio has now been unlocked on iOS, Android, etc.
                        var o = function() {
                            // Fix Android can not play in suspend state.
                            i._autoResume();
                            // Create an empty buffer.
                            var n = e.ctx.createBufferSource();
                            n.buffer = e._scratchBuffer, n.connect(e.ctx.destination), // Play the empty buffer.
                            void 0 === n.start ? n.noteOn(0) : n.start(0), // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
                            "function" == typeof e.ctx.resume && e.ctx.resume(), // Setup a timeout to check that we are unlocked on the next event loop.
                            n.onended = function() {
                                n.disconnect(0), // Update the unlocked state and prevent this check from happening again.
                                e._mobileEnabled = true, e.mobileAutoEnable = false, // Remove the touch start listener.
                                document.removeEventListener("touchend", o, true);
                            };
                        };
                        // Setup a touch start listener to attempt an unlock in.
                        return document.addEventListener("touchend", o, true), e;
                    }
                },
                /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
                _autoSuspend: function() {
                    var e = this;
                    if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && i.usingWebAudio) {
                        // Check if any sounds are playing.
                        for (var n = 0; n < e._howls.length; n++) if (e._howls[n]._webAudio) for (var t = 0; t < e._howls[n]._sounds.length; t++) if (!e._howls[n]._sounds[t]._paused) return e;
                        // If no sound has played after 30 seconds, suspend the context.
                        return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout(function() {
                            e.autoSuspend && (e._suspendTimer = null, e.state = "suspending", e.ctx.suspend().then(function() {
                                e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume());
                            }));
                        }, 3e4), e;
                    }
                },
                /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
                _autoResume: function() {
                    var e = this;
                    if (e.ctx && void 0 !== e.ctx.resume && i.usingWebAudio) return "running" === e.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), 
                    e._suspendTimer = null) : "suspended" === e.state ? (e.ctx.resume().then(function() {
                        e.state = "running";
                        // Emit to all Howls that the audio has resumed.
                        for (var n = 0; n < e._howls.length; n++) e._howls[n]._emit("resume");
                    }), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = true), 
                    e;
                }
            };
            // Setup the global audio controller.
            var i = new a(), u = function(e) {
                var n = this;
                // Throw an error if no source is provided.
                if (!e.src || 0 === e.src.length) return void console.error("An array of source files must be passed with any new Howl.");
                n.init(e);
            };
            u.prototype = {
                /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
                init: function(e) {
                    var n = this;
                    // If we don't have an AudioContext created yet, run the setup.
                    // Setup user-defined default properties.
                    // Setup all other default properties.
                    // Setup event listeners.
                    // Web Audio or HTML5 Audio?
                    // Automatically try to enable audio on iOS.
                    // Keep track of this Howl group in the global controller.
                    // If they selected autoplay, add a play event to the load queue.
                    // Load the source file unless otherwise specified.
                    return i.ctx || p(), n._autoplay = e.autoplay || false, n._format = "string" != typeof e.format ? e.format : [ e.format ], 
                    n._html5 = e.html5 || false, n._muted = e.mute || false, n._loop = e.loop || false, 
                    n._pool = e.pool || 5, n._preload = "boolean" != typeof e.preload || e.preload, 
                    n._rate = e.rate || 1, n._sprite = e.sprite || {}, n._src = "string" != typeof e.src ? e.src : [ e.src ], 
                    n._volume = void 0 !== e.volume ? e.volume : 1, n._duration = 0, n._state = "unloaded", 
                    n._sounds = [], n._endTimers = {}, n._queue = [], n._onend = e.onend ? [ {
                        fn: e.onend
                    } ] : [], n._onfade = e.onfade ? [ {
                        fn: e.onfade
                    } ] : [], n._onload = e.onload ? [ {
                        fn: e.onload
                    } ] : [], n._onloaderror = e.onloaderror ? [ {
                        fn: e.onloaderror
                    } ] : [], n._onpause = e.onpause ? [ {
                        fn: e.onpause
                    } ] : [], n._onplay = e.onplay ? [ {
                        fn: e.onplay
                    } ] : [], n._onstop = e.onstop ? [ {
                        fn: e.onstop
                    } ] : [], n._onmute = e.onmute ? [ {
                        fn: e.onmute
                    } ] : [], n._onvolume = e.onvolume ? [ {
                        fn: e.onvolume
                    } ] : [], n._onrate = e.onrate ? [ {
                        fn: e.onrate
                    } ] : [], n._onseek = e.onseek ? [ {
                        fn: e.onseek
                    } ] : [], n._onresume = [], n._webAudio = i.usingWebAudio && !n._html5, void 0 !== i.ctx && i.ctx && i.mobileAutoEnable && i._enableMobileAudio(), 
                    i._howls.push(n), n._autoplay && n._queue.push({
                        event: "play",
                        action: function() {
                            n.play();
                        }
                    }), n._preload && n.load(), n;
                },
                /**
     * Load the audio file.
     * @return {Howler}
     */
                load: function() {
                    var e = this, n = null;
                    // If no audio is available, quit immediately.
                    if (i.noAudio) return void e._emit("loaderror", null, "No audio support.");
                    // Make sure our source is in an array.
                    "string" == typeof e._src && (e._src = [ e._src ]);
                    // Loop through the sources and pick the first one that is compatible.
                    for (var t = 0; t < e._src.length; t++) {
                        var o, r;
                        if (e._format && e._format[t]) // If an extension was specified, use that instead.
                        o = e._format[t]; else {
                            if ("string" != typeof (// Make sure the source is a string.
                            r = e._src[t])) {
                                e._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                continue;
                            }
                            // Extract the file extension from the URL or base64 data URI.
                            o = /^data:audio\/([^;,]+);/i.exec(r), o || (o = /\.([^.]+)$/.exec(r.split("?", 1)[0])), 
                            o && (o = o[1].toLowerCase());
                        }
                        // Check if this extension is available.
                        if (// Log a warning if no extension was found.
                        o || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), 
                        o && i.codecs(o)) {
                            n = e._src[t];
                            break;
                        }
                    }
                    // If the hosting page is HTTPS and the source isn't,
                    // drop down to HTML5 Audio to avoid Mixed Content errors.
                    // Create a new sound object and add it to the pool.
                    // Load and decode the audio data for playback.
                    return n ? (e._src = n, e._state = "loading", "https:" === window.location.protocol && "http:" === n.slice(0, 5) && (e._html5 = true, 
                    e._webAudio = false), new s(e), e._webAudio && _(e), e) : void e._emit("loaderror", null, "No codec support for selected audio sources.");
                },
                /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
                play: function(e, n) {
                    var t = this, o = null;
                    // Determine if a sprite, sound id or nothing was passed
                    if ("number" == typeof e) o = e, e = null; else {
                        if ("string" == typeof e && "loaded" === t._state && !t._sprite[e]) // If the passed sprite doesn't exist, do nothing.
                        return null;
                        if (void 0 === e) {
                            // Use the default sound sprite (plays the full audio length).
                            e = "__default";
                            for (var r = 0, a = 0; a < t._sounds.length; a++) t._sounds[a]._paused && !t._sounds[a]._ended && (r++, 
                            o = t._sounds[a]._id);
                            1 === r ? e = null : o = null;
                        }
                    }
                    // Get the selected node, or get one from the pool.
                    var u = o ? t._soundById(o) : t._inactiveSound();
                    // If the sound doesn't exist, do nothing.
                    if (!u) return null;
                    // If the sound hasn't loaded, we must wait to get the audio's duration.
                    // We also need to wait to make sure we don't run into race conditions with
                    // the order of function calls.
                    if (// Select the sprite definition.
                    o && !e && (e = u._sprite || "__default"), "loaded" !== t._state) {
                        // Set the sprite value on this sound.
                        u._sprite = e, // Makr this sounded as not ended in case another sound is played before this one loads.
                        u._ended = false;
                        // Add the sound to the queue to be played on load.
                        var s = u._id;
                        return t._queue.push({
                            event: "play",
                            action: function() {
                                t.play(s);
                            }
                        }), s;
                    }
                    // Don't play the sound if an id was passed and it is already playing.
                    if (o && !u._paused) // Trigger the play event, in order to keep iterating through queue.
                    return n || setTimeout(function() {
                        t._emit("play", u._id);
                    }, 0), u._id;
                    // Make sure the AudioContext isn't suspended, and resume it if it is.
                    t._webAudio && i._autoResume();
                    // Determine how long to play for and where to start playing.
                    var d = Math.max(0, u._seek > 0 ? u._seek : t._sprite[e][0] / 1e3), _ = Math.max(0, (t._sprite[e][0] + t._sprite[e][1]) / 1e3 - d), l = 1e3 * _ / Math.abs(u._rate);
                    // Update the parameters of the sound
                    u._paused = false, u._ended = false, u._sprite = e, u._seek = d, u._start = t._sprite[e][0] / 1e3, 
                    u._stop = (t._sprite[e][0] + t._sprite[e][1]) / 1e3, u._loop = !!(u._loop || t._sprite[e][2]);
                    // Begin the actual playback.
                    var c = u._node;
                    if (t._webAudio) {
                        // Fire this when the sound is ready to play to begin Web Audio playback.
                        var f = function() {
                            t._refreshBuffer(u);
                            // Setup the playback params.
                            var e = u._muted || t._muted ? 0 : u._volume;
                            c.gain.setValueAtTime(e, i.ctx.currentTime), u._playStart = i.ctx.currentTime, // Play the sound using the supported method.
                            void 0 === c.bufferSource.start ? u._loop ? c.bufferSource.noteGrainOn(0, d, 86400) : c.bufferSource.noteGrainOn(0, d, _) : u._loop ? c.bufferSource.start(0, d, 86400) : c.bufferSource.start(0, d, _), 
                            // Start a new timer if none is present.
                            l !== 1 / 0 && (t._endTimers[u._id] = setTimeout(t._ended.bind(t, u), l)), n || setTimeout(function() {
                                t._emit("play", u._id);
                            }, 0);
                        }, p = "running" === i.state;
                        if ("loaded" === t._state && p) f(); else {
                            // Wait for the audio to load and then begin playback.
                            var v = p || "loaded" !== t._state ? "load" : "resume";
                            t.once(v, f, p ? u._id : null), // Cancel the end timer.
                            t._clearTimer(u._id);
                        }
                    } else {
                        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
                        var m = function() {
                            c.currentTime = d, c.muted = u._muted || t._muted || i._muted || c.muted, c.volume = u._volume * i.volume(), 
                            c.playbackRate = u._rate, c.play(), // Setup the new end timer.
                            l !== 1 / 0 && (t._endTimers[u._id] = setTimeout(t._ended.bind(t, u), l)), n || t._emit("play", u._id);
                        }, h = "loaded" === t._state && (window && window.ejecta || !c.readyState && i._navigator.isCocoonJS);
                        if (4 === c.readyState || h) m(); else {
                            var g = function() {
                                // Begin playback.
                                m(), // Clear this listener.
                                c.removeEventListener(i._canPlayEvent, g, false);
                            };
                            c.addEventListener(i._canPlayEvent, g, false), // Cancel the end timer.
                            t._clearTimer(u._id);
                        }
                    }
                    return u._id;
                },
                /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
                pause: function(e) {
                    var n = this;
                    // If the sound hasn't loaded, add it to the load queue to pause when capable.
                    if ("loaded" !== n._state) return n._queue.push({
                        event: "pause",
                        action: function() {
                            n.pause(e);
                        }
                    }), n;
                    for (var t = n._getSoundIds(e), o = 0; o < t.length; o++) {
                        // Clear the end timer.
                        n._clearTimer(t[o]);
                        // Get the sound.
                        var r = n._soundById(t[o]);
                        if (r && !r._paused && (// Reset the seek position.
                        r._seek = n.seek(t[o]), r._rateSeek = 0, r._paused = true, // Stop currently running fades.
                        n._stopFade(t[o]), r._node)) if (n._webAudio) {
                            // Make sure the sound has been created.
                            if (!r._node.bufferSource) continue;
                            void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), 
                            // Clean up the buffer source.
                            n._cleanBuffer(r._node);
                        } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
                        // Fire the pause event, unless `true` is passed as the 2nd argument.
                        arguments[1] || n._emit("pause", r ? r._id : null);
                    }
                    return n;
                },
                /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
                stop: function(e, n) {
                    var t = this;
                    // If the sound hasn't loaded, add it to the load queue to stop when capable.
                    if ("loaded" !== t._state) return t._queue.push({
                        event: "stop",
                        action: function() {
                            t.stop(e);
                        }
                    }), t;
                    for (var o = t._getSoundIds(e), r = 0; r < o.length; r++) {
                        // Clear the end timer.
                        t._clearTimer(o[r]);
                        // Get the sound.
                        var a = t._soundById(o[r]);
                        a && (// Reset the seek position.
                        a._seek = a._start || 0, a._rateSeek = 0, a._paused = true, a._ended = true, // Stop currently running fades.
                        t._stopFade(o[r]), a._node && (t._webAudio ? // Make sure the sound's AudioBufferSourceNode has been created.
                        a._node.bufferSource && (void 0 === a._node.bufferSource.stop ? a._node.bufferSource.noteOff(0) : a._node.bufferSource.stop(0), 
                        // Clean up the buffer source.
                        t._cleanBuffer(a._node)) : isNaN(a._node.duration) && a._node.duration !== 1 / 0 || (a._node.currentTime = a._start || 0, 
                        a._node.pause())), n || t._emit("stop", a._id));
                    }
                    return t;
                },
                /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
                mute: function(e, n) {
                    var t = this;
                    // If the sound hasn't loaded, add it to the load queue to mute when capable.
                    if ("loaded" !== t._state) return t._queue.push({
                        event: "mute",
                        action: function() {
                            t.mute(e, n);
                        }
                    }), t;
                    // If applying mute/unmute to all sounds, update the group's value.
                    if (void 0 === n) {
                        if ("boolean" != typeof e) return t._muted;
                        t._muted = e;
                    }
                    for (var o = t._getSoundIds(n), r = 0; r < o.length; r++) {
                        // Get the sound.
                        var a = t._soundById(o[r]);
                        a && (a._muted = e, t._webAudio && a._node ? a._node.gain.setValueAtTime(e ? 0 : a._volume, i.ctx.currentTime) : a._node && (a._node.muted = !!i._muted || e), 
                        t._emit("mute", a._id));
                    }
                    return t;
                },
                /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
                volume: function() {
                    var e, n, t = this, o = arguments;
                    // Determine the values based on arguments.
                    if (0 === o.length) // Return the value of the groups' volume.
                    return t._volume;
                    if (1 === o.length || 2 === o.length && void 0 === o[1]) {
                        t._getSoundIds().indexOf(o[0]) >= 0 ? n = parseInt(o[0], 10) : e = parseFloat(o[0]);
                    } else o.length >= 2 && (e = parseFloat(o[0]), n = parseInt(o[1], 10));
                    // Update the volume or return the current volume.
                    var r;
                    if (!(void 0 !== e && e >= 0 && e <= 1)) return r = n ? t._soundById(n) : t._sounds[0], 
                    r ? r._volume : 0;
                    // If the sound hasn't loaded, add it to the load queue to change volume when capable.
                    if ("loaded" !== t._state) return t._queue.push({
                        event: "volume",
                        action: function() {
                            t.volume.apply(t, o);
                        }
                    }), t;
                    // Set the group volume.
                    void 0 === n && (t._volume = e), // Update one or all volumes.
                    n = t._getSoundIds(n);
                    for (var a = 0; a < n.length; a++) // Get the sound.
                    (r = t._soundById(n[a])) && (r._volume = e, // Stop currently running fades.
                    o[2] || t._stopFade(n[a]), t._webAudio && r._node && !r._muted ? r._node.gain.setValueAtTime(e, i.ctx.currentTime) : r._node && !r._muted && (r._node.volume = e * i.volume()), 
                    t._emit("volume", r._id));
                    return t;
                },
                /**
     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
                fade: function(e, n, t, o) {
                    var r = this, a = Math.abs(e - n), u = e > n ? "out" : "in", s = a / .01, d = s > 0 ? t / s : t;
                    // If the sound hasn't loaded, add it to the load queue to fade when capable.
                    if (// Since browsers clamp timeouts to 4ms, we need to clamp our steps to that too.
                    d < 4 && (s = Math.ceil(s / (4 / d)), d = 4), "loaded" !== r._state) return r._queue.push({
                        event: "fade",
                        action: function() {
                            r.fade(e, n, t, o);
                        }
                    }), r;
                    // Set the volume to the start position.
                    r.volume(e, o);
                    for (var _ = r._getSoundIds(o), l = 0; l < _.length; l++) {
                        // Get the sound.
                        var c = r._soundById(_[l]);
                        // Create a linear fade or fall back to timeouts with HTML5 Audio.
                        if (c) {
                            // If we are using Web Audio, let the native methods do the actual fade.
                            if (// Stop the previous fade if no sprite is being used (otherwise, volume handles this).
                            o || r._stopFade(_[l]), r._webAudio && !c._muted) {
                                var f = i.ctx.currentTime, p = f + t / 1e3;
                                c._volume = e, c._node.gain.setValueAtTime(e, f), c._node.gain.linearRampToValueAtTime(n, p);
                            }
                            var v = e;
                            c._interval = setInterval(function(t, a) {
                                // Update the volume amount, but only if the volume should change.
                                s > 0 && (v += "in" === u ? .01 : -.01), // Make sure the volume is in the right bounds.
                                v = Math.max(0, v), v = Math.min(1, v), // Round to within 2 decimal points.
                                v = Math.round(100 * v) / 100, // Change the volume.
                                r._webAudio ? (void 0 === o && (r._volume = v), a._volume = v) : r.volume(v, t, true), 
                                // When the fade is complete, stop it and fire event.
                                (n < e && v <= n || n > e && v >= n) && (clearInterval(a._interval), a._interval = null, 
                                r.volume(n, t), r._emit("fade", t));
                            }.bind(r, _[l], c), d);
                        }
                    }
                    return r;
                },
                /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
                _stopFade: function(e) {
                    var n = this, t = n._soundById(e);
                    return t && t._interval && (n._webAudio && t._node.gain.cancelScheduledValues(i.ctx.currentTime), 
                    clearInterval(t._interval), t._interval = null, n._emit("fade", e)), n;
                },
                /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
                loop: function() {
                    var e, n, t, o = this, r = arguments;
                    // Determine the values for loop and id.
                    if (0 === r.length) // Return the grou's loop value.
                    return o._loop;
                    if (1 === r.length) {
                        if ("boolean" != typeof r[0]) // Return this sound's loop value.
                        return !!(t = o._soundById(parseInt(r[0], 10))) && t._loop;
                        e = r[0], o._loop = e;
                    } else 2 === r.length && (e = r[0], n = parseInt(r[1], 10));
                    for (var a = o._getSoundIds(n), i = 0; i < a.length; i++) (t = o._soundById(a[i])) && (t._loop = e, 
                    o._webAudio && t._node && t._node.bufferSource && (t._node.bufferSource.loop = e, 
                    e && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop)));
                    return o;
                },
                /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
                rate: function() {
                    var e, n, t = this, o = arguments;
                    // Determine the values based on arguments.
                    if (0 === o.length) // We will simply return the current rate of the first node.
                    n = t._sounds[0]._id; else if (1 === o.length) {
                        // First check if this is an ID, and if not, assume it is a new rate value.
                        var r = t._getSoundIds(), a = r.indexOf(o[0]);
                        a >= 0 ? n = parseInt(o[0], 10) : e = parseFloat(o[0]);
                    } else 2 === o.length && (e = parseFloat(o[0]), n = parseInt(o[1], 10));
                    // Update the playback rate or return the current value.
                    var u;
                    if ("number" != typeof e) return u = t._soundById(n), u ? u._rate : t._rate;
                    // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
                    if ("loaded" !== t._state) return t._queue.push({
                        event: "rate",
                        action: function() {
                            t.rate.apply(t, o);
                        }
                    }), t;
                    // Set the group rate.
                    void 0 === n && (t._rate = e), // Update one or all volumes.
                    n = t._getSoundIds(n);
                    for (var s = 0; s < n.length; s++) if (// Get the sound.
                    u = t._soundById(n[s])) {
                        // Keep track of our position when the rate changed and update the playback
                        // start position so we can properly adjust the seek position for time elapsed.
                        u._rateSeek = t.seek(n[s]), u._playStart = t._webAudio ? i.ctx.currentTime : u._playStart, 
                        u._rate = e, // Change the playback rate.
                        t._webAudio && u._node && u._node.bufferSource ? u._node.bufferSource.playbackRate.value = e : u._node && (u._node.playbackRate = e);
                        // Reset the timers.
                        var d = t.seek(n[s]), _ = (t._sprite[u._sprite][0] + t._sprite[u._sprite][1]) / 1e3 - d, l = 1e3 * _ / Math.abs(u._rate);
                        // Start a new end timer if sound is already playing.
                        !t._endTimers[n[s]] && u._paused || (t._clearTimer(n[s]), t._endTimers[n[s]] = setTimeout(t._ended.bind(t, u), l)), 
                        t._emit("rate", u._id);
                    }
                    return t;
                },
                /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
                seek: function() {
                    var e, n, t = this, o = arguments;
                    // Determine the values based on arguments.
                    if (0 === o.length) // We will simply return the current position of the first node.
                    n = t._sounds[0]._id; else if (1 === o.length) {
                        // First check if this is an ID, and if not, assume it is a new seek position.
                        var r = t._getSoundIds(), a = r.indexOf(o[0]);
                        a >= 0 ? n = parseInt(o[0], 10) : (n = t._sounds[0]._id, e = parseFloat(o[0]));
                    } else 2 === o.length && (e = parseFloat(o[0]), n = parseInt(o[1], 10));
                    // If there is no ID, bail out.
                    if (void 0 === n) return t;
                    // If the sound hasn't loaded, add it to the load queue to seek when capable.
                    if ("loaded" !== t._state) return t._queue.push({
                        event: "seek",
                        action: function() {
                            t.seek.apply(t, o);
                        }
                    }), t;
                    // Get the sound.
                    var u = t._soundById(n);
                    if (u) {
                        if (!("number" == typeof e && e >= 0)) {
                            if (t._webAudio) {
                                var s = t.playing(n) ? i.ctx.currentTime - u._playStart : 0, d = u._rateSeek ? u._rateSeek - u._seek : 0;
                                return u._seek + (d + s * Math.abs(u._rate));
                            }
                            return u._node.currentTime;
                        }
                        // Pause the sound and update position for restarting playback.
                        var _ = t.playing(n);
                        _ && t.pause(n, true), // Move the position of the track and cancel timer.
                        u._seek = e, u._ended = false, t._clearTimer(n), // Restart the playback if the sound was playing.
                        _ && t.play(n, true), // Update the seek position for HTML5 Audio.
                        !t._webAudio && u._node && (u._node.currentTime = e), t._emit("seek", n);
                    }
                    return t;
                },
                /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
                playing: function(e) {
                    var n = this;
                    // Check the passed sound ID (if any).
                    if ("number" == typeof e) {
                        var t = n._soundById(e);
                        return !!t && !t._paused;
                    }
                    // Otherwise, loop through all sounds and check if any are playing.
                    for (var o = 0; o < n._sounds.length; o++) if (!n._sounds[o]._paused) return true;
                    return false;
                },
                /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
                duration: function(e) {
                    var n = this, t = n._duration, o = n._soundById(e);
                    return o && (t = n._sprite[o._sprite][1] / 1e3), t;
                },
                /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
                state: function() {
                    return this._state;
                },
                /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
                unload: function() {
                    for (var e = this, n = e._sounds, t = 0; t < n.length; t++) {
                        // Remove the source or disconnect.
                        if (// Stop the sound if it is currently playing.
                        n[t]._paused || e.stop(n[t]._id), !e._webAudio) {
                            /MSIE |Trident\//.test(i._navigator && i._navigator.userAgent) || (n[t]._node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"), 
                            // Remove any event listeners.
                            n[t]._node.removeEventListener("error", n[t]._errorFn, false), n[t]._node.removeEventListener(i._canPlayEvent, n[t]._loadFn, false);
                        }
                        // Empty out all of the nodes.
                        delete n[t]._node, // Make sure all timers are cleared out.
                        e._clearTimer(n[t]._id);
                        // Remove the references in the global Howler object.
                        var o = i._howls.indexOf(e);
                        o >= 0 && i._howls.splice(o, 1);
                    }
                    // Delete this sound from the cache (if no other Howl is using it).
                    var r = true;
                    for (t = 0; t < i._howls.length; t++) if (i._howls[t]._src === e._src) {
                        r = false;
                        break;
                    }
                    // Clear global errors.
                    // Clear out `self`.
                    return d && r && delete d[e._src], i.noAudio = false, e._state = "unloaded", e._sounds = [], 
                    e = null, null;
                },
                /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
                on: function(e, n, t, o) {
                    var r = this, a = r["_on" + e];
                    return "function" == typeof n && a.push(o ? {
                        id: t,
                        fn: n,
                        once: o
                    } : {
                        id: t,
                        fn: n
                    }), r;
                },
                /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
                off: function(e, n, t) {
                    var o = this, r = o["_on" + e], a = 0;
                    if (// Allow passing just an event and ID.
                    "number" == typeof n && (t = n, n = null), n || t) // Loop through event store and remove the passed function.
                    for (a = 0; a < r.length; a++) {
                        var i = t === r[a].id;
                        if (n === r[a].fn && i || !n && i) {
                            r.splice(a, 1);
                            break;
                        }
                    } else if (e) // Clear out all events of this type.
                    o["_on" + e] = []; else {
                        // Clear out all events of every type.
                        var u = Object.keys(o);
                        for (a = 0; a < u.length; a++) 0 === u[a].indexOf("_on") && Array.isArray(o[u[a]]) && (o[u[a]] = []);
                    }
                    return o;
                },
                /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
                once: function(e, n, t) {
                    var o = this;
                    // Setup the event listener.
                    return o.on(e, n, t, 1), o;
                },
                /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
                _emit: function(e, n, t) {
                    // Loop through event store and fire all functions.
                    for (var o = this, r = o["_on" + e], a = r.length - 1; a >= 0; a--) r[a].id && r[a].id !== n && "load" !== e || (setTimeout(function(e) {
                        e.call(this, n, t);
                    }.bind(o, r[a].fn), 0), // If this event was setup with `once`, remove it.
                    r[a].once && o.off(e, r[a].fn, r[a].id));
                    return o;
                },
                /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
                _loadQueue: function() {
                    var e = this;
                    if (e._queue.length > 0) {
                        var n = e._queue[0];
                        // don't move onto the next task until this one is done
                        e.once(n.event, function() {
                            e._queue.shift(), e._loadQueue();
                        }), n.action();
                    }
                    return e;
                },
                /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
                _ended: function(e) {
                    var n = this, t = e._sprite;
                    // If we are using IE and there was network latency we may be clipping
                    // audio before it completes playing. Lets check the node to make sure it
                    // believes it has completed, before ending the playback.
                    if (!n._webAudio && n._node && !n._node.ended) return setTimeout(n._ended.bind(n, e), 100), 
                    n;
                    // Should this sound loop?
                    var o = !!(e._loop || n._sprite[t][2]);
                    // Restart this timer if on a Web Audio loop.
                    if (// Fire the ended event.
                    n._emit("end", e._id), // Restart the playback for HTML5 Audio loop.
                    !n._webAudio && o && n.stop(e._id, true).play(e._id), n._webAudio && o) {
                        n._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = i.ctx.currentTime;
                        var r = 1e3 * (e._stop - e._start) / Math.abs(e._rate);
                        n._endTimers[e._id] = setTimeout(n._ended.bind(n, e), r);
                    }
                    // Mark the node as paused.
                    // Clean up the buffer source.
                    // Attempt to auto-suspend AudioContext if no sounds are still playing.
                    // When using a sprite, end the track.
                    return n._webAudio && !o && (e._paused = true, e._ended = true, e._seek = e._start || 0, 
                    e._rateSeek = 0, n._clearTimer(e._id), n._cleanBuffer(e._node), i._autoSuspend()), 
                    n._webAudio || o || n.stop(e._id), n;
                },
                /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
                _clearTimer: function(e) {
                    var n = this;
                    return n._endTimers[e] && (clearTimeout(n._endTimers[e]), delete n._endTimers[e]), 
                    n;
                },
                /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
                _soundById: function(e) {
                    // Loop through all sounds and find the one with this ID.
                    for (var n = this, t = 0; t < n._sounds.length; t++) if (e === n._sounds[t]._id) return n._sounds[t];
                    return null;
                },
                /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
                _inactiveSound: function() {
                    var e = this;
                    e._drain();
                    // Find the first inactive node to recycle.
                    for (var n = 0; n < e._sounds.length; n++) if (e._sounds[n]._ended) return e._sounds[n].reset();
                    // If no inactive node was found, create a new one.
                    return new s(e);
                },
                /**
     * Drain excess inactive sounds from the pool.
     */
                _drain: function() {
                    var e = this, n = e._pool, t = 0, o = 0;
                    // If there are less sounds than the max pool size, we are done.
                    if (!(e._sounds.length < n)) {
                        // Count the number of inactive sounds.
                        for (o = 0; o < e._sounds.length; o++) e._sounds[o]._ended && t++;
                        // Remove excess inactive sounds, going in reverse order.
                        for (o = e._sounds.length - 1; o >= 0; o--) {
                            if (t <= n) return;
                            e._sounds[o]._ended && (// Disconnect the audio source when using Web Audio.
                            e._webAudio && e._sounds[o]._node && e._sounds[o]._node.disconnect(0), // Remove sounds until we have the pool size.
                            e._sounds.splice(o, 1), t--);
                        }
                    }
                },
                /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
                _getSoundIds: function(e) {
                    var n = this;
                    if (void 0 === e) {
                        for (var t = [], o = 0; o < n._sounds.length; o++) t.push(n._sounds[o]._id);
                        return t;
                    }
                    return [ e ];
                },
                /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
                _refreshBuffer: function(e) {
                    var n = this;
                    // Setup the buffer source for playback.
                    // Connect to the correct node.
                    // Setup looping and playback rate.
                    return e._node.bufferSource = i.ctx.createBufferSource(), e._node.bufferSource.buffer = d[n._src], 
                    e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), 
                    e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, 
                    e._node.bufferSource.loopEnd = e._stop), e._node.bufferSource.playbackRate.value = e._rate, 
                    n;
                },
                /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
                _cleanBuffer: function(e) {
                    var n = this;
                    if (n._scratchBuffer) {
                        e.bufferSource.onended = null, e.bufferSource.disconnect(0);
                        try {
                            e.bufferSource.buffer = n._scratchBuffer;
                        } catch (e) {}
                    }
                    return e.bufferSource = null, n;
                }
            };
            /** Single Sound Methods **/
            /***************************************************************************/
            /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
            var s = function(e) {
                this._parent = e, this.init();
            };
            s.prototype = {
                /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
                init: function() {
                    var e = this, n = e._parent;
                    // Setup the default parameters.
                    // Generate a unique ID for this sound.
                    // Add itself to the parent's pool.
                    // Create the new node.
                    return e._muted = n._muted, e._loop = n._loop, e._volume = n._volume, e._rate = n._rate, 
                    e._seek = 0, e._paused = true, e._ended = true, e._sprite = "__default", e._id = ++i._counter, 
                    n._sounds.push(e), e.create(), e;
                },
                /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
                create: function() {
                    var e = this, n = e._parent, t = i._muted || e._muted || e._parent._muted ? 0 : e._volume;
                    // Create the gain node for controlling volume (the source will connect to this).
                    // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
                    // Listen for 'canplaythrough' event to let us know the sound is ready.
                    // Setup the new audio node.
                    // Begin loading the source.
                    return n._webAudio ? (e._node = void 0 === i.ctx.createGain ? i.ctx.createGainNode() : i.ctx.createGain(), 
                    e._node.gain.setValueAtTime(t, i.ctx.currentTime), e._node.paused = true, e._node.connect(i.masterGain)) : (e._node = new Audio(), 
                    e._errorFn = e._errorListener.bind(e), e._node.addEventListener("error", e._errorFn, false), 
                    e._loadFn = e._loadListener.bind(e), e._node.addEventListener(i._canPlayEvent, e._loadFn, false), 
                    e._node.src = n._src, e._node.preload = "auto", e._node.volume = t * i.volume(), 
                    e._node.load()), e;
                },
                /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
                reset: function() {
                    var e = this, n = e._parent;
                    // Reset all of the parameters of this sound.
                    // Generate a new ID so that it isn't confused with the previous sound.
                    return e._muted = n._muted, e._loop = n._loop, e._volume = n._volume, e._rate = n._rate, 
                    e._seek = 0, e._rateSeek = 0, e._paused = true, e._ended = true, e._sprite = "__default", 
                    e._id = ++i._counter, e;
                },
                /**
     * HTML5 Audio error listener callback.
     */
                _errorListener: function() {
                    var e = this;
                    // Fire an error event and pass back the code.
                    e._parent._emit("loaderror", e._id, e._node.error ? e._node.error.code : 0), // Clear the event listener.
                    e._node.removeEventListener("error", e._errorFn, false);
                },
                /**
     * HTML5 Audio canplaythrough listener callback.
     */
                _loadListener: function() {
                    var e = this, n = e._parent;
                    // Round up the duration to account for the lower precision in HTML5 Audio.
                    n._duration = Math.ceil(10 * e._node.duration) / 10, // Setup a sprite if none is defined.
                    0 === Object.keys(n._sprite).length && (n._sprite = {
                        __default: [ 0, 1e3 * n._duration ]
                    }), "loaded" !== n._state && (n._state = "loaded", n._emit("load"), n._loadQueue()), 
                    // Clear the event listener.
                    e._node.removeEventListener(i._canPlayEvent, e._loadFn, false);
                }
            };
            /** Helper Methods **/
            /***************************************************************************/
            var d = {}, _ = function(e) {
                var n = e._src;
                // Check if the buffer has already been cached and use it instead.
                if (d[n]) // Set the duration from the cache.
                // Load the sound into this Howl.
                return e._duration = d[n].duration, void f(e);
                if (/^data:[^;]+;base64,/.test(n)) {
                    for (var t = atob(n.split(",")[1]), o = new Uint8Array(t.length), r = 0; r < t.length; ++r) o[r] = t.charCodeAt(r);
                    c(o.buffer, e);
                } else {
                    // Load the buffer from the URL.
                    var a = new XMLHttpRequest();
                    a.open("GET", n, true), a.responseType = "arraybuffer", a.onload = function() {
                        // Make sure we get a successful response back.
                        var n = (a.status + "")[0];
                        if ("0" !== n && "2" !== n && "3" !== n) return void e._emit("loaderror", null, "Failed loading audio file with status: " + a.status + ".");
                        c(a.response, e);
                    }, a.onerror = function() {
                        // If there is an error, switch to HTML5 Audio.
                        e._webAudio && (e._html5 = true, e._webAudio = false, e._sounds = [], delete d[n], 
                        e.load());
                    }, l(a);
                }
            }, l = function(e) {
                try {
                    e.send();
                } catch (n) {
                    e.onerror();
                }
            }, c = function(e, n) {
                // Decode the buffer into an audio source.
                i.ctx.decodeAudioData(e, function(e) {
                    e && n._sounds.length > 0 && (d[n._src] = e, f(n, e));
                }, function() {
                    n._emit("loaderror", null, "Decoding audio data failed.");
                });
            }, f = function(e, n) {
                // Set the duration.
                n && !e._duration && (e._duration = n.duration), // Setup a sprite if none is defined.
                0 === Object.keys(e._sprite).length && (e._sprite = {
                    __default: [ 0, 1e3 * e._duration ]
                }), // Fire the loaded event.
                "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue());
            }, p = function() {
                // Check if we are using Web Audio and setup the AudioContext if we are.
                try {
                    "undefined" != typeof AudioContext ? i.ctx = new AudioContext() : "undefined" != typeof webkitAudioContext ? i.ctx = new webkitAudioContext() : i.usingWebAudio = false;
                } catch (e) {
                    i.usingWebAudio = false;
                }
                // Check if a webview is being used on iOS8 or earlier (rather than the browser).
                // If it is, disable Web Audio as it causes crashing.
                var e = /iP(hone|od|ad)/.test(i._navigator && i._navigator.platform), n = i._navigator && i._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), t = n ? parseInt(n[1], 10) : null;
                if (e && t && t < 9) {
                    var o = /safari/.test(i._navigator && i._navigator.userAgent.toLowerCase());
                    (i._navigator && i._navigator.standalone && !o || i._navigator && !i._navigator.standalone && !o) && (i.usingWebAudio = false);
                }
                // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
                i.usingWebAudio && (i.masterGain = void 0 === i.ctx.createGain ? i.ctx.createGainNode() : i.ctx.createGain(), 
                i.masterGain.gain.value = i._muted ? 0 : 1, i.masterGain.connect(i.ctx.destination)), 
                // Re-run the setup on Howler.
                i._setup();
            };
            o = [], void 0 !== (r = function() {
                return {
                    Howler: i,
                    Howl: u
                };
            }.apply(n, o)) && (e.exports = r), n.Howler = i, n.Howl = u, // Define globally in case AMD is not available or unused.
            "undefined" != typeof window ? (window.HowlerGlobal = a, window.Howler = i, window.Howl = u, 
            window.Sound = s) : void 0 !== t && (// Add to global in Node.js (for testing, etc).
            t.HowlerGlobal = a, t.Howler = i, t.Howl = u, t.Sound = s);
        }(), /*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.0.4
 *  howlerjs.com
 *
 *  (c) 2013-2017, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
        function() {
            "use strict";
            // Setup default properties.
            HowlerGlobal.prototype._pos = [ 0, 0, 0 ], HowlerGlobal.prototype._orientation = [ 0, 0, -1, 0, 1, 0 ], 
            /** Global Methods **/
            /***************************************************************************/
            /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
            HowlerGlobal.prototype.stereo = function(e) {
                var n = this;
                // Stop right here if not using Web Audio.
                if (!n.ctx || !n.ctx.listener) return n;
                // Loop through all Howls and update their stereo panning.
                for (var t = n._howls.length - 1; t >= 0; t--) n._howls[t].stereo(e);
                return n;
            }, /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
            HowlerGlobal.prototype.pos = function(e, n, t) {
                var o = this;
                // Stop right here if not using Web Audio.
                // Stop right here if not using Web Audio.
                // Set the defaults for optional 'y' & 'z'.
                return o.ctx && o.ctx.listener ? (n = "number" != typeof n ? o._pos[1] : n, t = "number" != typeof t ? o._pos[2] : t, 
                "number" != typeof e ? o._pos : (o._pos = [ e, n, t ], o.ctx.listener.setPosition(o._pos[0], o._pos[1], o._pos[2]), 
                o)) : o;
            }, /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
            HowlerGlobal.prototype.orientation = function(e, n, t, o, r, a) {
                var i = this;
                // Stop right here if not using Web Audio.
                if (!i.ctx || !i.ctx.listener) return i;
                // Set the defaults for optional 'y' & 'z'.
                var u = i._orientation;
                return n = "number" != typeof n ? u[1] : n, t = "number" != typeof t ? u[2] : t, 
                o = "number" != typeof o ? u[3] : o, r = "number" != typeof r ? u[4] : r, a = "number" != typeof a ? u[5] : a, 
                "number" != typeof e ? u : (i._orientation = [ e, n, t, o, r, a ], i.ctx.listener.setOrientation(e, n, t, o, r, a), 
                i);
            }, /** Group Methods **/
            /***************************************************************************/
            /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
            Howl.prototype.init = function(e) {
                return function(n) {
                    var t = this;
                    // Complete initilization with howler.js core's init function.
                    // Setup user-defined default properties.
                    // Setup event listeners.
                    return t._orientation = n.orientation || [ 1, 0, 0 ], t._stereo = n.stereo || null, 
                    t._pos = n.pos || null, t._pannerAttr = {
                        coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : 360,
                        coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : 360,
                        coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : 0,
                        distanceModel: void 0 !== n.distanceModel ? n.distanceModel : "inverse",
                        maxDistance: void 0 !== n.maxDistance ? n.maxDistance : 1e4,
                        panningModel: void 0 !== n.panningModel ? n.panningModel : "HRTF",
                        refDistance: void 0 !== n.refDistance ? n.refDistance : 1,
                        rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : 1
                    }, t._onstereo = n.onstereo ? [ {
                        fn: n.onstereo
                    } ] : [], t._onpos = n.onpos ? [ {
                        fn: n.onpos
                    } ] : [], t._onorientation = n.onorientation ? [ {
                        fn: n.onorientation
                    } ] : [], e.call(this, n);
                };
            }(Howl.prototype.init), /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
            Howl.prototype.stereo = function(n, t) {
                var o = this;
                // Stop right here if not using Web Audio.
                if (!o._webAudio) return o;
                // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
                if ("loaded" !== o._state) return o._queue.push({
                    event: "stereo",
                    action: function() {
                        o.stereo(n, t);
                    }
                }), o;
                // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
                var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                // Setup the group's stereo panning if no ID is passed.
                if (void 0 === t) {
                    // Return the group's stereo panning if no parameters are passed.
                    if ("number" != typeof n) return o._stereo;
                    o._stereo = n, o._pos = [ n, 0, 0 ];
                }
                for (var a = o._getSoundIds(t), i = 0; i < a.length; i++) {
                    // Get the sound.
                    var u = o._soundById(a[i]);
                    if (u) {
                        if ("number" != typeof n) return u._stereo;
                        u._stereo = n, u._pos = [ n, 0, 0 ], u._node && (// If we are falling back, make sure the panningModel is equalpower.
                        u._pannerAttr.panningModel = "equalpower", // Check if there is a panner setup and create a new one if not.
                        u._panner && u._panner.pan || e(u, r), "spatial" === r ? u._panner.setPosition(n, 0, 0) : u._panner.pan.value = n), 
                        o._emit("stereo", u._id);
                    }
                }
                return o;
            }, /**
   * Get/set the 3D spatial position of the audio source for this sound or
   * all in the group. The most common usage is to set the 'x' position for
   * left/right panning. Setting any value higher than 1.0 will begin to
   * decrease the volume of the sound as it moves further away.
   * @param  {Number} x  The x-position of the audio from -1000.0 to 1000.0.
   * @param  {Number} y  The y-position of the audio from -1000.0 to 1000.0.
   * @param  {Number} z  The z-position of the audio from -1000.0 to 1000.0.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
            Howl.prototype.pos = function(n, t, o, r) {
                var a = this;
                // Stop right here if not using Web Audio.
                if (!a._webAudio) return a;
                // If the sound hasn't loaded, add it to the load queue to change position when capable.
                if ("loaded" !== a._state) return a._queue.push({
                    event: "pos",
                    action: function() {
                        a.pos(n, t, o, r);
                    }
                }), a;
                // Setup the group's spatial position if no ID is passed.
                if (// Set the defaults for optional 'y' & 'z'.
                t = "number" != typeof t ? 0 : t, o = "number" != typeof o ? -.5 : o, void 0 === r) {
                    // Return the group's spatial position if no parameters are passed.
                    if ("number" != typeof n) return a._pos;
                    a._pos = [ n, t, o ];
                }
                for (var i = a._getSoundIds(r), u = 0; u < i.length; u++) {
                    // Get the sound.
                    var s = a._soundById(i[u]);
                    if (s) {
                        if ("number" != typeof n) return s._pos;
                        s._pos = [ n, t, o ], s._node && (// Check if there is a panner setup and create a new one if not.
                        s._panner && !s._panner.pan || e(s, "spatial"), s._panner.setPosition(n, t, o)), 
                        a._emit("pos", s._id);
                    }
                }
                return a;
            }, /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
            Howl.prototype.orientation = function(n, t, o, r) {
                var a = this;
                // Stop right here if not using Web Audio.
                if (!a._webAudio) return a;
                // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
                if ("loaded" !== a._state) return a._queue.push({
                    event: "orientation",
                    action: function() {
                        a.orientation(n, t, o, r);
                    }
                }), a;
                // Setup the group's spatial orientation if no ID is passed.
                if (// Set the defaults for optional 'y' & 'z'.
                t = "number" != typeof t ? a._orientation[1] : t, o = "number" != typeof o ? a._orientation[2] : o, 
                void 0 === r) {
                    // Return the group's spatial orientation if no parameters are passed.
                    if ("number" != typeof n) return a._orientation;
                    a._orientation = [ n, t, o ];
                }
                for (var i = a._getSoundIds(r), u = 0; u < i.length; u++) {
                    // Get the sound.
                    var s = a._soundById(i[u]);
                    if (s) {
                        if ("number" != typeof n) return s._orientation;
                        s._orientation = [ n, t, o ], s._node && (// Check if there is a panner setup and create a new one if not.
                        s._panner || (// Make sure we have a position to setup the node with.
                        s._pos || (s._pos = a._pos || [ 0, 0, -.5 ]), e(s, "spatial")), s._panner.setOrientation(n, t, o)), 
                        a._emit("orientation", s._id);
                    }
                }
                return a;
            }, /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) There will be no volume reduction inside this angle.
   *     coneOuterAngle - (360 by default) The volume will be reduced to a constant value of
   *                      `coneOuterGain` outside this angle.
   *     coneOuterGain - (0 by default) The amount of volume reduction outside of `coneOuterAngle`.
   *     distanceModel - ('inverse' by default) Determines algorithm to use to reduce volume as audio moves
   *                      away from listener. Can be `linear`, `inverse` or `exponential`.
   *     maxDistance - (10000 by default) Volume won't reduce between source/listener beyond this distance.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *     refDistance - (1 by default) A reference distance for reducing volume as the source
   *                    moves away from the listener.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener.
   * 
   * @return {Howl/Object} Returns self or current panner attributes.
   */
            Howl.prototype.pannerAttr = function() {
                var n, t, o, r = this, a = arguments;
                // Stop right here if not using Web Audio.
                if (!r._webAudio) return r;
                // Determine the values based on arguments.
                if (0 === a.length) // Return the group's panner attribute values.
                return r._pannerAttr;
                if (1 === a.length) {
                    if ("object" != typeof a[0]) // Return this sound's panner attribute values.
                    return o = r._soundById(parseInt(a[0], 10)), o ? o._pannerAttr : r._pannerAttr;
                    n = a[0], // Set the grou's panner attribute values.
                    void 0 === t && (r._pannerAttr = {
                        coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : r._coneInnerAngle,
                        coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : r._coneOuterAngle,
                        coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : r._coneOuterGain,
                        distanceModel: void 0 !== n.distanceModel ? n.distanceModel : r._distanceModel,
                        maxDistance: void 0 !== n.maxDistance ? n.maxDistance : r._maxDistance,
                        panningModel: void 0 !== n.panningModel ? n.panningModel : r._panningModel,
                        refDistance: void 0 !== n.refDistance ? n.refDistance : r._refDistance,
                        rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : r._rolloffFactor
                    });
                } else 2 === a.length && (n = a[0], t = parseInt(a[1], 10));
                for (var i = r._getSoundIds(t), u = 0; u < i.length; u++) if (o = r._soundById(i[u])) {
                    // Merge the new values into the sound.
                    var s = o._pannerAttr;
                    s = {
                        coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : s.coneInnerAngle,
                        coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : s.coneOuterAngle,
                        coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : s.coneOuterGain,
                        distanceModel: void 0 !== n.distanceModel ? n.distanceModel : s.distanceModel,
                        maxDistance: void 0 !== n.maxDistance ? n.maxDistance : s.maxDistance,
                        panningModel: void 0 !== n.panningModel ? n.panningModel : s.panningModel,
                        refDistance: void 0 !== n.refDistance ? n.refDistance : s.refDistance,
                        rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : s.rolloffFactor
                    };
                    // Update the panner values or create a new panner if none exists.
                    var d = o._panner;
                    d ? (d.coneInnerAngle = s.coneInnerAngle, d.coneOuterAngle = s.coneOuterAngle, d.coneOuterGain = s.coneOuterGain, 
                    d.distanceModel = s.distanceModel, d.maxDistance = s.maxDistance, d.panningModel = s.panningModel, 
                    d.refDistance = s.refDistance, d.rolloffFactor = s.rolloffFactor) : (// Make sure we have a position to setup the node with.
                    o._pos || (o._pos = r._pos || [ 0, 0, -.5 ]), // Create a new panner node.
                    e(o, "spatial"));
                }
                return r;
            }, /** Single Sound Methods **/
            /***************************************************************************/
            /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
            Sound.prototype.init = function(e) {
                return function() {
                    var n = this, t = n._parent;
                    // Setup user-defined default properties.
                    n._orientation = t._orientation, n._stereo = t._stereo, n._pos = t._pos, n._pannerAttr = t._pannerAttr, 
                    // Complete initilization with howler.js core Sound's init function.
                    e.call(this), // If a stereo or position was specified, set it up.
                    n._stereo ? t.stereo(n._stereo) : n._pos && t.pos(n._pos[0], n._pos[1], n._pos[2], n._id);
                };
            }(Sound.prototype.init), /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
            Sound.prototype.reset = function(e) {
                return function() {
                    var n = this, t = n._parent;
                    // Complete resetting of the sound.
                    // Reset all spatial plugin properties on this sound.
                    return n._orientation = t._orientation, n._pos = t._pos, n._pannerAttr = t._pannerAttr, 
                    e.call(this);
                };
            }(Sound.prototype.reset);
            /** Helper Methods **/
            /***************************************************************************/
            /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
            var e = function(e, n) {
                n = n || "spatial", // Create the new panner node.
                "spatial" === n ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, 
                e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, 
                e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, 
                e._panner.panningModel = e._pannerAttr.panningModel, e._panner.refDistance = e._pannerAttr.refDistance, 
                e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), 
                e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), 
                e._panner.pan.value = e._stereo), e._panner.connect(e._node), // Update the connections.
                e._paused || e._parent.pause(e._id, true).play(e._id);
            };
        }();
    }).call(n, t(2));
}, /* 2 */
/***/
function(e, n) {
    var t;
    // This works in non-strict mode
    t = function() {
        return this;
    }();
    try {
        // This works if eval is allowed (see CSP)
        t = t || Function("return this")() || (0, eval)("this");
    } catch (e) {
        // This works if the window reference is available
        "object" == typeof window && (t = window);
    }
    // g can still be undefined, but nothing to do about it...
    // We return undefined, instead of nothing here, so it's
    // easier to handle this case. if(!global) { ...}
    e.exports = t;
} ]);